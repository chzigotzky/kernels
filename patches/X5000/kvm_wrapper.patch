diff -rupN a/arch/powerpc/kvm/e500_mmu_host.c b/arch/powerpc/kvm/e500_mmu_host.c
--- a/arch/powerpc/kvm/e500_mmu_host.c	2025-01-05 23:13:40.000000000 +0100
+++ b/arch/powerpc/kvm/e500_mmu_host.c	2025-01-08 07:23:50.786895563 +0100
@@ -444,7 +444,7 @@ static inline int kvmppc_e500_shadow_map
 
 	if (likely(!pfnmap)) {
 		tsize_pages = 1UL << (tsize + 10 - PAGE_SHIFT);
-		pfn = __kvm_faultin_pfn(slot, gfn, FOLL_WRITE, NULL, &page);
+		pfn = kvm_faultin_writable_pfn(slot, gfn, &page);	
 		if (is_error_noslot_pfn(pfn)) {
 			if (printk_ratelimit())
 				pr_err("%s: real page not found for gfn %lx\n",
diff -rupN a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
--- a/arch/x86/kvm/vmx/vmx.c	2025-01-05 23:13:40.000000000 +0100
+++ b/arch/x86/kvm/vmx/vmx.c	2025-01-08 07:28:21.392045189 +0100
@@ -6800,7 +6800,6 @@ void vmx_set_apic_access_page_addr(struc
 	struct page *refcounted_page;
 	unsigned long mmu_seq;
 	kvm_pfn_t pfn;
-	bool writable;
 
 	/* Defer reload until vmcs01 is the current VMCS. */
 	if (is_guest_mode(vcpu)) {
@@ -6836,7 +6835,7 @@ void vmx_set_apic_access_page_addr(struc
 	 * controls the APIC-access page memslot, and only deletes the memslot
 	 * if APICv is permanently inhibited, i.e. the memslot won't reappear.
 	 */
-	pfn = __kvm_faultin_pfn(slot, gfn, FOLL_WRITE, &writable, &refcounted_page);
+	pfn = kvm_faultin_writable_pfn(slot, gfn, &refcounted_page);	
 	if (is_error_noslot_pfn(pfn))
 		return;
 
diff -rupN a/include/linux/kvm_host.h b/include/linux/kvm_host.h
--- a/include/linux/kvm_host.h	2025-01-05 23:13:40.000000000 +0100
+++ b/include/linux/kvm_host.h	2025-01-08 07:30:38.770596975 +0100
@@ -1276,6 +1276,14 @@ static inline kvm_pfn_t kvm_faultin_pfn(
 				 write ? FOLL_WRITE : 0, writable, refcounted_page);
 }
 
+static inline kvm_pfn_t kvm_faultin_writable_pfn(const struct kvm_memory_slot *slot,
+                         gfn_t gfn, struct page **refcounted_page)
+{
+    bool writable;
+
+    return __kvm_faultin_pfn(slot, gfn, FOLL_WRITE, &writable, refcounted_page);
+}
+
 int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,
 			int len);
 int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len);
